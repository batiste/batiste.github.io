<html>
<body>
<h2>Simplex noise coloured map</h2>
<p>Use arrows to move the canvas. This produce an
  infinite scrollable map that is kinda interesting
</p>
<script src="./simplex-noise.js"></script>
<script src="./pixi.js"></script>

<script>
const width = 1200
const height = 600
const tilesetSize = 48
// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(width, height, {backgroundColor : 0x1099bb});

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

// app.stage.addChild(container);
const spriteSheet = PIXI.BaseTexture.fromImage('tileset.png');

let tilePalette = [
  [0,0],
  [2,1],
  [0,3],
  [3,3],
  [4,4],
  [5,5],
  [7,5],
  [8,5],
]
let textures = []
for(let i=0; i<tilePalette.length; i++) {
  textures.push(new PIXI.Texture(spriteSheet, new PIXI.Rectangle(
    tilePalette[i][0] * 48, tilePalette[i][1] * 48, 48, 48)))
}

let simplex = new SimplexNoise('blop');

let dx = 0;
let dy = 0;
let velocity = 4

// we will be using a north-south, west-east coordinate system

document.onkeydown = function(e) {
    switch (e.keyCode) {
        case 37:
            // left arrow
            dx = Math.max(dx - velocity, -5 * velocity)
            break;
        case 38:
            // up arrow
            dy = Math.max(dy - velocity, -5 * velocity)
            break;
        case 39:
            // rigth arrow
            dx = Math.min(dx + velocity, 5 * velocity)
            break;
        case 40:
            // down arrow
            dy = Math.min(dy + velocity, 5 * velocity)
            break;
    }
};

let x = 0
let y = 0

function tile(value) {
  return textures[Math.round((tilePalette.length - 1) * value)]
}

function colorForPos(x, y) {
  let scale1 = 0.01
  let largedetails = 10 * (simplex.noise2D(scale1 * x, scale1 * y) + 1);
  let scale2 = 0.1
  let smalldetails = simplex.noise2D(scale2 * x, scale2 * y) + 1;
  return color((largedetails + smalldetails) / 22.0)
}

function tileForPos(x, y) {
  let scale1 = 0.01
  let largedetails = 10 * (simplex.noise2D(scale1 * x, scale1 * y) + 1);
  let scale2 = 0.1
  let smalldetails = simplex.noise2D(scale2 * x, scale2 * y) + 1;
  return tile((largedetails + smalldetails) / 22.0)
}

let spriteDrawList = []

function drawBg(delta) {
  x = x + (dx * delta)
  y = y + (dy * delta)

  let verticalTiles = 1 + (height / tilesetSize);
  let horizontalTiles = 1 + (width / tilesetSize);
  let restX = x % tilesetSize;
  let restY = y % tilesetSize;
  let top = parseInt((y - restY) / tilesetSize, 10);
  let left = parseInt((x - restX) / tilesetSize, 10);

  for(let i=-1; i<=verticalTiles; i++) {
    for(let j=-1; j<=horizontalTiles; j++) {
      let texture = tileForPos(j + left, i + top);
      let sprite = new PIXI.Sprite(texture)
      sprite.x = (j * tilesetSize) - restX
      sprite.y = (i * tilesetSize) - restY
      spriteDrawList.push(sprite)
      app.stage.addChild(sprite);
    }
    j = 0
  }
}

// Listen for animate update
app.ticker.add(function(delta) {
    for(let i=0; i<spriteDrawList.length; i++) {
      app.stage.removeChild(spriteDrawList[i])
    }
    spriteDrawList = []
    drawBg(delta)
});

</script>