<html>
<body>
<script src="./simplex-noise.js"></script>
<script src="./pixi.js"></script>

<script>
const width = 1200
const height = 500
const tilesetSize = 48
PIXI.settings.SCALE_MODE = PIXI.SCALE_MODES.NEAREST;
// PIXI.settings.RESOLUTION = 1 / window.devicePixelRatio;
// The application will create a renderer using WebGL, if possible,
// with a fallback to a canvas render. It will also setup the ticker
// and the root stage PIXI.Container
const app = new PIXI.Application(width, height, {backgroundColor : 0x1099bb});

// The application will create a canvas element for you that you
// can then insert into the DOM
document.body.appendChild(app.view);

// app.stage.addChild(container);
const spriteSheet = PIXI.BaseTexture.fromImage('tileset.png');

let waterTiles = [
  [0,0],
  [2,1],
  [0,3],
]

let grassTiles = [
  [3,3],
  [4,4],
  [5,5],
]

let groundTiles = [
  [7,5],
  [8,5],
]

function mtextures(tilePalette) {
  let textures = []
  for(let i=0; i<tilePalette.length; i++) {
    textures.push(new PIXI.Texture(spriteSheet, new PIXI.Rectangle(
      tilePalette[i][0] * 48, tilePalette[i][1] * 48, 48, 48)))
  }
  return textures
}
const wText = mtextures(waterTiles)
const gText = mtextures(grassTiles)
const grText = mtextures(groundTiles)

const grassWaterSouth = [
  [10, 19]
]
const grassWaterSouthText = mtextures(grassWaterSouth)
const waterGrassNorth = [
  [10, 20]
]
const waterGrassNorthText = mtextures(waterGrassNorth)
const grassWaterWest = [
  [1, 15],
  [1, 15],
  [1, 16],
  [1, 17]
]
const grassWaterWestText = mtextures(grassWaterWest)

const grassWaterEast = [
  [18, 15],
  [18, 15],
  [18, 16],
  [18, 17]
]
const grassWaterEastText = mtextures(grassWaterEast)

const grassWaterLeftTop = [[1, 14]]
const grassWaterLeftTopText = mtextures(grassWaterLeftTop)

// i = y
function textureForTile(tiles, y, x) {
  let tile = tiles[y][x]
  if(tile.type === 'water') {
    if(tiles[y - 1] && tiles[y - 1][x].type === 'grass') {
      return waterGrassNorthText[0]
    }
    return wText[Math.round((wText.length - 1) * tile.value)]
  }
  if(tile.type === 'grass') {
    let waterTop = tiles[y - 1] && tiles[y - 1][x].type === 'water'
    let waterBottom = tiles[y + 1] && tiles[y + 1][x].type === 'water'
    let waterLeft = tiles[y][x - 1] && tiles[y][x - 1].type === 'water'
    let waterRight = tiles[y][x + 1] && tiles[y][x + 1].type === 'water'
    if(waterLeft && waterTop) {
      return grassWaterLeftTopText[0]
    }
    if(waterBottom) {
      return grassWaterSouthText[0]
    }
    if(waterLeft) {
      let index = Math.round((10000000 * tile.value) % (grassWaterWestText.length - 1));
      return grassWaterWestText[index]
    }
    if(waterRight) {
      let index = Math.round((10000000 * tile.value) % (grassWaterEastText.length - 1));
      return grassWaterEastText[index]
    }
    return gText[Math.round((gText.length - 1) * tile.value)]
  }
  return grText[Math.round((grText.length - 1) * tile.value)]
}

let simplex = new SimplexNoise('blop');

let dx = 0;
let dy = 0;
let velocity = 4

// we will be using a north-south, west-east coordinate system

document.onkeydown = function(e) {
    switch (e.keyCode) {
        case 37:
            // left arrow
            dx = Math.max(dx - velocity, -5 * velocity)
            break;
        case 38:
            // up arrow
            dy = Math.max(dy - velocity, -5 * velocity)
            break;
        case 39:
            // rigth arrow
            dx = Math.min(dx + velocity, 5 * velocity)
            break;
        case 40:
            // down arrow
            dy = Math.min(dy + velocity, 5 * velocity)
            break;
    }
};

let x = 0
let y = 0

function normalize(val, max, min) { return (val - min) / (max - min); }

function tile(value) {
  if(value < 0.3) {
    return {type: 'water', value: normalize(value, 0.3, 0)};
  }
  if(value < 0.8) {
    return {type: 'grass', value: normalize(value, 0.8, 0.3)};
  }
  return {type: 'ground', value: normalize(value, 1.0, 0.8)};
}

function colorForPos(x, y) {
  let scale1 = 0.01
  let largedetails = 10 * (simplex.noise2D(scale1 * x, scale1 * y) + 1);
  let scale2 = 0.1
  let smalldetails = simplex.noise2D(scale2 * x, scale2 * y) + 1;
  return color((largedetails + smalldetails) / 22.0)
}

function tileForPos(x, y) {
  let scale1 = 0.01
  let largedetails = 10 * (simplex.noise2D(scale1 * x, scale1 * y) + 1);
  let scale2 = 0.1
  let smalldetails = simplex.noise2D(scale2 * x, scale2 * y) + 1;
  return tile((largedetails + smalldetails) / 22.0)
}

let spriteDrawList = []

function drawBg(delta) {
  x = x + (dx * delta)
  y = y + (dy * delta)

  let verticalTiles = 1 + (height / tilesetSize);
  let horizontalTiles = 1 + (width / tilesetSize);
  let restX = x % tilesetSize;
  let restY = y % tilesetSize;
  let top = parseInt((y - restY) / tilesetSize, 10);
  let left = parseInt((x - restX) / tilesetSize, 10);

  let tiles = []
  
  for(let i=0; i <= verticalTiles + 1; i++) {
    tiles.push([])
    for(let j=0; j<= horizontalTiles + 1; j++) {
      tiles[i].push(tileForPos(j + left - 1, i + top - 1));
    }
  }

  for(let i=0; i <= verticalTiles + 1; i++) {
    for(let j=0; j<= horizontalTiles + 1; j++) {
      let tile = tiles[i][j]
      let texture = textureForTile(tiles, i, j)
      let sprite = new PIXI.Sprite(texture)
      sprite.x = ((j - 1) * tilesetSize) - restX
      sprite.y = ((i - 1) * tilesetSize) - restY
      spriteDrawList.push(sprite)
      app.stage.addChild(sprite);
    }
  }

}

// Listen for animate update
app.ticker.add(function(delta) {
    for(let i=0; i<spriteDrawList.length; i++) {
      app.stage.removeChild(spriteDrawList[i])
    }
    spriteDrawList = []
    drawBg(delta)
});

</script>